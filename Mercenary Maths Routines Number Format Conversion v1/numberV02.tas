;
; **** ZP ABSOLUTE ADRESSES **** 
;
SCREEN_POS_LO = $02
SCREEN_POS_HI = $03
SCREEN_FLIP = $24
LINE_INC = $66
SCREEN_POS_PTR = $02
SCREEN_0 = $40
SCREEN_1 = $60

ab06 = $06 ; math temp?
ab07 = $07 ; math temp?

LINE_FRACTION_ab08 = $08

ab08 = $08 ; math temp? line draw fraction?
ab09 = $09 ; math temp?

REGA = $0E
REGX = $0F
REGY = $20

ab18 = $18
	
FP_MULTIPLY_POWER_SIGN = $22
FP_MULTIPLY_VALUE = $23
FP_DIVIDE_POWER_SIGN = FP_MULTIPLY_POWER_SIGN
FP_DIVIDE_VALUE = FP_MULTIPLY_VALUE

ROT_LO = $2C
ROT_HI = $2D

SIN_LO = $3C
SIN_HI = $3D
COS_LO = $3E
COS_HI = $3F

CURR_X_LSB = $72
CURR_X_MSB = $73
CURR_X_HSB = $74
CURR_Z_LSB = $78
CURR_Z_MSB = $79
CURR_Z_HSB = $7A

INC_COUNT = $1D

FP_SIGN = $01

IRQ = $FFFE

OVERFLOW = $E000 ; overflow?

        * = $801

STARTUP
	SEI

	LDX #$FF
	TXS
	
 LDA #$00
 STA $D020
 LDA #$01 ; $00
 STA $D021
 LDA #$0B ; $00
 STA $D022
 LDA #$0C ; $00
 STA $D023

 LDA #$00 ; $01 ; colour 11 
 LDX #<$D800
 LDY #>$D800
 STX SCREEN_POS_LO+0
 STY SCREEN_POS_LO+1
 LDX #>1000 
 LDY #<1000
 JSR MEMSET

 LDA #$BC ;$65 ; colour 01 (0000????) and colour 10 (????0000) - bank 1
 LDX #<(SCREEN_COLOUR)
 LDY #>(SCREEN_COLOUR)
 STX SCREEN_POS_LO+0
 STY SCREEN_POS_LO+1
 LDX #>1000 
 LDY #<1000
 JSR MEMSET

 LDA #255
 LDX #<SCREEN0
 LDY #>SCREEN0
 STX SCREEN_POS_LO+0
 STY SCREEN_POS_LO+1
 LDX #>8000 
 LDY #<8000
 JSR MEMSET

 LDA #255
 LDX #<SCREEN1
 LDY #>SCREEN1
 STX SCREEN_POS_LO+0
 STY SCREEN_POS_LO+1
 LDX #>8000 
 LDY #<8000
 JSR MEMSET
 
	LDA #$35
	STA $1
	LDA #$70
	STA $D018
	LDA #$3B
	STA $D011
;	LDA #$00 
;	STA $D021
	LDA #$18
	STA $D016
	LDA #<IRQ_1
	STA $FFFE
	LDA #>IRQ_1
	STA $FFFF

 LDA #$7F
 STA $DC0D  ; disable timer interrupts which can be generated by the two CIA chips
 STA $DD0D  ; the kernal uses such an interrupt to flash the cursor and scan the keyboard, so we better stop it.

 LDA $DC0D  ; by reading this two registers we negate any pending CIA irqs.
 LDA $DD0D  ; if we don't do this, a pending CIA irq might occur after we finish setting up our irq. we don't want that to happen.

  LDA #$01   ; this is how to tell the VICII to generate a raster interrupt
 STA $D01A
	
 LDA #2 ; SCRNBANK
 STA $DD00 ; bank
	
	LDA #$BA
	STA $D012
	LDA #$01
	STA $D019

	LDA		#0
	STA		ROT_LO
	STA		ROT_HI
	
	STA		CURR_X_MSB
	STA		CURR_X_HSB
	STA		CURR_Z_MSB
	STA		CURR_Z_HSB


 LDY #$FF ; #$FE ; #$FF
 LDX #$DD ; #$82 ; #$F2 ; #$8E
 LDA #$1C ; #$78 ; #$07 ; #$6B
 STY CURR_X_HSB
 STX CURR_X_MSB
 STA CURR_X_LSB
 LDY #$FF ; #$01 ; #$00
 LDX #$D6 ; #$7D ; #$0E
 LDA #$EC ; #$44 ; #$B4
 STY CURR_Z_HSB
 STX CURR_Z_MSB
 STA CURR_Z_LSB
	
	CLI

MAIN_LOOP
			JSR 	JOYSTICK
			JSR 	DRAW_SCREEN

			LDA INC_COUNT
			LDX #0
			LDY	#112
			JSR	HEX8

			
			LDX CURR_X_MSB
			LDA CURR_X_HSB
			LDY	#0
			JSR	HEX16
			LDA CURR_X_LSB
			LDX #32
			LDY	#0
			JSR	HEX8

			LDX CURR_Z_MSB
			LDA CURR_Z_HSB
			LDY	#6
			JSR	HEX16
			LDA CURR_Z_LSB
			LDX #32
			LDY	#6
			JSR	HEX8


			LDY	CURR_X_LSB
			LDX	CURR_X_MSB
			LDA	CURR_X_HSB
			JSR	BIT24TOFP
			STY	TEST_VALUE
			STA	TEST_POWER_SIGN
			STY	TEST_X_VALUE
			STA	TEST_X_POWER_SIGN

			LDX	TEST_VALUE
			LDA TEST_POWER_SIGN
			LDY	#18
			JSR	HEX16

			LDY	CURR_Z_LSB
			LDX	CURR_Z_MSB
			LDA	CURR_Z_HSB
			JSR	BIT24TOFP
			STY	TEST_VALUE
			STA	TEST_POWER_SIGN
			STY	TEST_Z_VALUE
			STA	TEST_Z_POWER_SIGN

			LDX	TEST_VALUE
			LDA TEST_POWER_SIGN
			LDY	#24
			JSR	HEX16


			LDY 	TEST_X_POWER_SIGN
			LDX 	TEST_X_VALUE
			JSR FPTO16BIT
			TYA
			STX TEST_XREG
			TAX
			LDA TEST_XREG
			LDY	#36
			JSR	HEX16

			LDY 	TEST_Z_POWER_SIGN
			LDX 	TEST_Z_VALUE
			JSR FPTO16BIT
			TYA
			STX TEST_XREG
			TAX
			LDA TEST_XREG
			LDY	#42
			JSR	HEX16


			LDY 	TEST_X_POWER_SIGN
			LDX 	TEST_X_VALUE
			JSR FPTO8BIT
			LDX #0
			LDY	#48
			JSR	HEX8

			LDY 	TEST_Z_POWER_SIGN
			LDX 	TEST_Z_VALUE
			JSR FPTO8BIT
			LDX #0
			LDY	#54
			JSR	HEX8


;			LDX	TEST_VALUE
;			LDY TEST_POWER_SIGN
;			STX TEST_ADD_VALUE
;			STY TEST_ADD_POWER_SIGN

			LDX TEST_X_VALUE
			STX	ab08
			LDY TEST_X_POWER_SIGN
			STY	ab09

			LDX	TEST_Z_VALUE
			LDY TEST_Z_POWER_SIGN
			JSR FP_ADD
			TXA
			STY TEST_XREG
			TAY
			LDA TEST_XREG
			LDY	#66
			JSR	HEX16


;;			LDY	#$7C		; ffFF807C
;;			LDX	#$80
;;			LDA	#$FF
;;			STY	TEST_LSB
;;			STX	TEST_MSB
;;			STA	TEST_HSB

;;			LDX TEST_MSB
;;			LDA TEST_HSB
;;			LDY	#62
;;			JSR	HEX16
;;			LDA TEST_LSB
;;			LDX #32
;;			LDY	#62
;;			JSR	HEX8

;;			LDY	TEST_LSB
;;			LDX	TEST_MSB
;;			LDA	TEST_HSB
;;			JSR	BIT24TOFP
;;			STY	TEST_VALUE
;;			STA	TEST_POWER_SIGN
;;			LDX	TEST_VALUE
;;			LDA TEST_POWER_SIGN
;;			LDY	#68
;;			JSR	HEX16

;;			LDX	TEST_VALUE
;;			LDY TEST_POWER_SIGN
;;			STX TEST_ADD_VALUE
;;			STY TEST_ADD_POWER_SIGN

;;			LDY	#$9D		; 00007F9D
;;			LDX	#$7F
;;			LDA	#$00
;;			STY	TEST_LSB
;;			STX	TEST_MSB
;;			STA	TEST_HSB

;;			LDX TEST_MSB
;;			LDA TEST_HSB
;;			LDY	#74
;;			JSR	HEX16
;;			LDA TEST_LSB
;;			LDX #32
;;			LDY	#74
;;			JSR	HEX8

;;			LDY	TEST_LSB
;;			LDX	TEST_MSB
;;			LDA	TEST_HSB
;;			JSR	BIT24TOFP
;;			STY	TEST_VALUE
;;			STA	TEST_POWER_SIGN
;;			LDX	TEST_VALUE
;;			LDA TEST_POWER_SIGN
;;			LDY	#80
;;			JSR	HEX16

;;			LDX TEST_ADD_VALUE
;;			STX	ab08
;;			LDY TEST_ADD_POWER_SIGN
;;			STY	ab09

;;			LDX	TEST_VALUE
;;			LDY TEST_POWER_SIGN
;;			JSR FP_ADD
;;			TXA
;;			STY TEST_XREG
;;			TAY
;;			LDA TEST_XREG
;;			LDY	#86
;;			JSR	HEX16

			LDA 	TEST_X_POWER_SIGN
			STA		FP_MULTIPLY_POWER_SIGN
			LDA 	TEST_X_VALUE
			LDX		TEST_Z_VALUE
			LDY		TEST_Z_POWER_SIGN
			JSR		FP_MULTIPLY
			STY 	TEST_MUL_POWER_SIGN
			STA		TEST_MUL_VALUE

			LDA 	TEST_X_POWER_SIGN
			STA		FP_DIVIDE_POWER_SIGN
			LDX 	TEST_MUL_VALUE
			LDY		TEST_MUL_POWER_SIGN
			LDA 	TEST_X_VALUE
			JSR		FP_DIVIDE
			STX 	TEST_DIV_POWER_SIGN
			STA		TEST_DIV_VALUE

			LDX TEST_MUL_VALUE
			LDA TEST_MUL_POWER_SIGN
			LDY	#94
			JSR	HEX16
			LDX TEST_DIV_VALUE
			LDA TEST_DIV_POWER_SIGN
			LDY	#100
			JSR	HEX16

MAIN_LOOP_EXIT
			JMP MAIN_LOOP

TEST_LSB	.byte 0
TEST_MSB	.byte 0
TEST_HSB	.byte 0
TEST_VALUE 		.BYTE 0
TEST_POWER_SIGN	.BYTE 0
TEST_AREG	.byte 0
TEST_XREG	.byte 0
TEST_YREG	.byte 0
TEST_ADD_VALUE	.byte 0
TEST_ADD_POWER_SIGN .byte 0

TEST_MUL_VALUE		.BYTE 0 ; VALUE ?
TEST_MUL_POWER_SIGN	.BYTE 0 ; POWER SIGN ?
TEST_DIV_VALUE	.byte 0 ; VALUE ?
TEST_DIV_POWER_SIGN .byte 0 ; POWER SIGN ?

TEST_X_VALUE		.BYTE 0
TEST_X_POWER_SIGN	.BYTE 0
TEST_Z_VALUE		.BYTE 0
TEST_Z_POWER_SIGN	.BYTE 0

IRQ_1   		PHA
				LDA 	#$7E
				STA 	$D018   ;VIC Memory Control Register
				LDA 	#<IRQ_2
				STA 	IRQ
				LDA 	#>IRQ_2
				STA 	IRQ+1
				LDA 	#$00
				STA 	$D012	;Raster Position
				LDA 	#$1B
				STA 	$D011   ;VIC Control Register 1
				LDA 	#$08
				STA 	$D016   ;VIC Control Register 2
				LDA 	#$01
				STA 	$D019   ;VIC Interrupt Request Register (IRR)
				PLA 
NMI_NOP			RTI ; This is the irq handler for the NMI. Just returns without acknowledge. This prevents subsequent NMI's from interfering.

IRQ_2  			PHA
VIC_SCREEN_BANK	LDA 	#0
				STA 	$D018    ;VIC Memory Control Register
				LDA 	#<IRQ_1
				STA 	IRQ
				LDA 	#>IRQ_1
				STA 	IRQ+1
				LDA 	#178	; 186
				STA 	$D012    ;Raster Position
				LDA 	#$3B
				STA 	$D011    ;VIC Control Register 1
				LDA 	#$18
				STA 	$D016    ;VIC Control Register 2
				LDA 	#$01
				STA 	$D019    ;VIC Interrupt Request Register (IRR)
				PLA 
				RTI

MEMSET       STY    LSB_ONLY+1 ; store LSB count
             CPX    #0          ; MSB?     
             BEQ    LSB_ONLY   ; no
             LDY    #0          ; yes so reset LSB
MSB_LOOP  
LSB_LOOP      STA    (SCREEN_POS_LO),Y   ; clear whole MSB
               DEY 
               BNE    LSB_LOOP
              INC    SCREEN_POS_LO+1      ; inc MSB
              DEX               ; dec MSB count
              BNE    MSB_LOOP
LSB_ONLY    LDY    #0          ; LSB count 
             BEQ    MS_END
LAST_LSB_LOOP STA   (SCREEN_POS_LO),Y
               DEY 
               BNE   LAST_LSB_LOOP               
              STA   (SCREEN_POS_LO),Y     ; clear last Y (0)
MS_END      RTS

FP_DIVIDE	STA		FP_DIVIDE_VALUE	; inputs = X-(LO) + Y-(HI) + A (HI) + FP_MULTILPLY_LO - outputs = AY
			LDA 	LOG_TABLE,Y
			LDY 	FP_DIVIDE_POWER_SIGN
			SEC 
			SBC 	LOG_TABLE,Y
			TAY
			TXA
			LDX 	EXP_TABLE,Y
			ORA 	#$02
			BCS 	_FP_DIV_CNT
					SBC 	#$03	; subtract 00000011
					SEC 
_FP_DIV_CNT SBC 	FP_DIVIDE_VALUE
			AND 	#$FD
			RTS

; in
; A = first value
; FP_MULTIPLY_POWER_SIGN = first  power sign
; X = second value
; Y = SECOND power sign
; out
; Y = power sign
; A = value

FP_MULTIPLY	STA		FP_MULTIPLY_VALUE 		; store first value
			LDA 	LOG_TABLE,X				; get second value
			LDX 	FP_MULTIPLY_POWER_SIGN	; get first power sign
			CLC 
			ADC 	LOG_TABLE,X				; second value + first power sign ?
			TAX 							; store in x
			TYA 							; get second power sign
			LDY 	EXP_TABLE,X				; get ouput power sign
			BCC 	_FP_MUL_CNT
					ADC 	#$03			; add 4 (00000011)
					CLC 
_FP_MUL_CNT	ADC 	FP_MULTIPLY_VALUE		; add first value
			AND 	#$FD					; get output value
			RTS 

FPMUL		LDA LOG_TABLE,X		; fpMul - ; Input:  [08] = fp multiplier ;         XY   = fp multiplicand ; Output: [08] and XY = result
			LDX ab08
			CLC 
			ADC LOG_TABLE,X
			TAX 
			TYA 
			BCC _PF_MUL_CNT
				ADC #$03			; add 00000011
				CLC 
_PF_MUL_CNT   	ADC ab09
			BVS MATH_LIMIT 
			AND #$FD
			STA ab09
			TAY 
			LDA EXP_TABLE,X
			TAX 
			STA ab08
			RTS 

MATH_LIMIT	BPL _MATH_LIMIT_POS
			AND #$01
			ORA #$78
			TAY 
			LDX #$00
			STX ab08
			STY ab09
			RTS 

_MATH_LIMIT_POS	AND #$01
				ORA #$84

MATH_LIMIT_EXIT	TAY 
				LDX #$00
				STX ab08
				STY ab09
				RTS 

FPDIV		STY 	ab06	 ; fpDiv - Input:  [08] = fp divisor - XY   = fp dividend - Output: [08] and XY = result
			LDY 	ab08
			LDA 	LOG_TABLE,Y
			SEC 
			SBC 	LOG_TABLE,X
			TAX 
			LDA 	ab09
			ORA 	#$02
			BCS 	FPDIV_CONT
				SBC 	#$03		; subtract 00000011
				SEC 
FPDIV_CONT	SBC 	ab06
			BVS 	MATH_LIMIT 
			AND 	#$FD
			STA 	ab09
			TAY 
			LDA 	EXP_TABLE,X
			TAX 
			STA 	ab08
			RTS 



FPADD_CONT	LDA		ab18	; ($838B entry point)  
			LSR 
			BCS 	FPADD_CONT2
        TXA 
        ADC 	ab08
        ROR 
        INY 
        INY 
        INY 
        INY 
        TAX 
        STA 	ab08
        STY 	ab09
        RTS 

FP_ADD_ERR	TYA 
			ASL 
			BCC 	FP_ADD_ERR_1ST
				JMP 	FP_ADD_ERR_2ND
FPADD_CONT2
		TXA 
        SBC 	ab08
        BEQ 	FPADD_CONT3
			BCS 	FPADD_CONT6
			LDY 	ab09
			EOR 	#$FF
			ADC 	#$01
			JMP 	FPADD_CONT6

FPADD_CONT3		TYA 
				SEC 
				SBC 	#$24
				BVS 	_MATH_LIMIT_POS
				BVC 	MATH_LIMIT_EXIT
	
FP_ADD  TYA			; XY + 89	; transfer num1_hi to a
        SEC 					; set carry
        SBC 	ab09			; sub num2_hi from a
        BVS 	FP_ADD_ERR		; overflow so exit
        STA 	ab18			; ab18 = num1_hi - num2_hi
        ADC 	#$01			; add 1 + carry?
        BVS 	FP_ADD_ERR		; overflow so exit
        BMI 	FPADD_CONT8			
        LSR 					; divide by 2
        LSR 					; divide by 2
        BEQ 	FPADD_CONT		; if 0
        CMP 	#$09			; gt 9
        BCS 	FP_ADD_ERR_1ST	; yes
        EOR 	#$0F			; reverse 
        STA 	FP_ADD_JMP1 +1		; jump forward that amount
        LDA		ab08			; get num_hi
        SEC						; set carry 
        ROR 					; /2 and move carry into first bit

FP_ADD_JMP1 	BNE		b83B3 	; self modifiction code shift
        NOP 					; NA
        NOP 					; NA
        NOP 					; NA
        NOP 					; NA
        NOP 					; NA
        NOP 					; NA
        NOP 					; NA
b83B3   LSR 					; divide by 2
        LSR  					; divide by 2
        LSR  					; divide by 2
        LSR  					; divide by 2
        LSR  					; divide by 2
        LSR  					; divide by 2
        LSR  					; divide by 2
        STA 	ab06			; 
        LDA 	ab18
        LSR 					; divide by 2 - setting carry?
        TXA 					; transfer num1_lo to a
        BCS 	FPADD_CONT5			; carry set
FPADD_CONT4	ADC 	ab06
			BCC 	FPADD_CONT7
				LSR 				; divide by 2
				INY 				; y++
				INY 				; y++
				INY 				; y++
				INY 				; y++
FPADD_CONT7   	TAX
FP_ADD_ERR_1ST 
			STX 	ab08
			STY 	ab09
			RTS 

FPADD_CONT5	SBC ab06
			BCS FPADD_CONT7
FPADD_CONT6	STY ab06
        LDY #$00
FPADD_LOOP1		ASL 
				DEY 
				BCC		FPADD_LOOP1
        TAX 
        TYA 
        ASL 
        ASL 
        CLC 
        ADC 	ab06
        BVS 	FPADD_ERR3
			TAY 
			STX 	ab08
			STY 	ab09
			RTS 

FPADD_ERR3	LDX 	#<8400
			LDY 	#>8400
			STX 	ab08
			STY		ab09
			RTS 

FPADD_CONT8	CMP 	#$E0
			BCC 	FP_ADD_ERR_2ND
        LSR 
        LSR 
        AND #$07
        STA FP_ADD_JMP2 +1
		TXA 
        SEC 
        ROR
FP_ADD_JMP2	BNE b8408
        LSR 
        LSR 
        LSR 
b8408   LSR 
        LSR 
        LSR 
        LSR 
        STA ab06
        LDY ab09
        LDA ab18
        LSR 
        LDA ab08
        BCC FPADD_CONT4
        BCS FPADD_CONT5	; jmp
		
FP_ADD_ERR_2ND	LDX		ab08
				LDY 	ab09
				RTS 







COS_FP	INY 
SIN_FP	TYA 
		LSR 
		BCC 	SIN_CNT
				TXA 
				EOR #$FF
				TAX 
				TYA 
				LSR 
SIN_CNT AND 	#$01
		ORA 	SIN_MSB,X
		TAY 
		LDA 	SIN_LSB,X
		TAX 
		RTS 

; Y format = floating point position 
; bit0 = ignored / shifted out - first bit can be set to show negative?
; bit1 = ignored / shifted out
; bit2 = 
; bit3 = 
; bit4 = 
; bit5 = 
; bit6 = 
; bit7 = must be 0 or if set value must be gt FC for 1 to be added to result?

; X format = actual number
; bit0 = 
; bit1 = 
; bit2 = 
; bit3 = 
; bit4 = 
; bit5 = 
; bit6 = 
; bit7 = 

FPTO8BIT	TYA 				; input X/Y (mantisa/exponent) -  output X=HI/Y=LO ; transfer exponent? to a
			BMI		b849F		; if negative
			LSR 				; half and put bit into carry (carry unused)
			LSR 				; half and put bit into carry (carry unused)
			CMP 	#$07		; is it greater than 7
			BCS 	FP8BIT_ERR		; yes so error so exit with carry set
			STA 	FP8BIT_JMP +1	; no so self modifying code to jump forward a number of divides
			TXA 				; transfer mantisa? to a
			SEC 				; set carry
			ROR 				; /2 - putting 1 in top bit (and putting 0 in carry?) 
FP8BIT_JMP	BNE 	b848C		; jump forward self modifying code - always done as carry is set so ROR result is never 0
			LSR 				; /2
			LSR 				; /4
			LSR 				; /8
			LSR 				; /16
b848C   	LSR 				; /32
			LSR 				; /64
			LSR 				; /128
b848F   	ADC 	#0			; add carry?
			BMI 	b84A5		; if minus then error?
			TAX 				; backup result
			TYA 				; transfer y to a
			LSR					; / 2
			TXA 				; restore result
			BCC 	b849E		; clear carry so ok?
				EOR 	#$FF	; negate?
				ADC 	#$00	; negate by adding carry that is already set?
				CLC 			; clear carry for ok?
b849E   	RTS 				; exit

b849F   	CMP 	#$FC		; sets the carry flag if greater than (11111100 binary)
			LDA 	#$00		; resets the output x value? 
			BEQ 	b848F		; jump back into code

b84A5   	SEC 				; set carry for error?
FP8BIT_ERR	RTS 				; exit

FPTO16BIT	TYA					; input X/Y (mantisa/exponent) -  output X=HI/Y=LO	; transfer exponent? to a
			BMI 	b8501 		; if negative
			LSR 				; half and put bit into carry
			LSR 				; half and put bit into carry
;			CMP 	#15			; is it greater than 15
;			BCS 	FP8BIT_ERR		; yes so error so exit with carry set
			STA 	ab06		; store intermediate in temp var
			ASL 				; *2
			ADC 	ab06		; *3 
			STA 	FP16BIT_JMP +1	; number of bytes to jump
			LDA 	#0
			STA 	ab06		; clear result
			TXA 				; get input (mantisa?)
			SEC 				; set carry to move 1 into result
			ROR 				; rotate carry into high bit and low bit into carry
			ROR 	ab06		; rotate carry into result
FP16BIT_JMP BCC 	b84D2		; jump forward
			LSR 				; half and shift lowest bit into carry  
			ROR 	ab06		; half and rotate carry bit into result
			LSR 
			ROR 	ab06
			LSR 
			ROR 	ab06
			LSR 
			ROR 	ab06
			LSR 
			ROR 	ab06
b84D2   	LSR 
			ROR 	ab06
			LSR 
			ROR 	ab06
			LSR 
			ROR 	ab06
			LSR 
			ROR		ab06
			LSR 
			ROR 	ab06
			LSR 
			ROR 	ab06
			LSR 
			ROR 	ab06
			LSR 
			ROR 	ab06
			LSR 
			ROR 	ab06
			LSR 
			ROR 	ab06
			TAX 				; store low byte of result?
			TYA 				; get input (exponent?)
			LDY 	ab06		; store high byte of result?
			LSR 				; move 1st bit of input (sign) into carry
			BCC 	b8500		; clear so positive
				TXA 			; negtive so
				EOR 	#$FF	; negate x
				TAX 
				TYA 
				EOR 	#$FF	; negate y
				TAY 
				CLC 
b8500   RTS 					; no

b8501 		LSR 				; move 1st bit to carry
			BCC 	b850B		; set y/n
				LDX 	#$FF	; yes
				LDY 	#$FF
				CLC 
			RTS 
b850B   	LDX 	#0			; no
			LDY 	#0
			RTS 

; A = exponent = value of (first bit position set *4?) with sign in bit 0
; Y = mantissa = value of next 8 bits of the rest of the 8/16/24 bit number

BIT24TOFP 	STY		ab07 	; store lsb	; MATH_24BitToFP (FP.SetToObjectSpaceCoordinate24) ; Enter: A = Coordinate.MSB X = Coordinate.PSB Y = Coordinate.LSB ; Usese: [06].b  Temporary store for coordinate MSB ; Exit:  [08].fp Result, also stored in X:A (exp:man)
			STA 	ab06 	; store msb
			BPL 	_BIT24FP_POS	 ; positive ?

				LDA 	#0	 	; negative so 
				SEC 
				SBC 	ab07 	; negate lsb
				STA 	ab07
				TXA 			; negate psb
				EOR 	#$FF
				ADC 	#0
				TAX 
				LDA 	#0
				SBC 	ab06	; negate msb

_BIT24FP_POS	BNE 	_BIT24			; if msb not 0 - jump to set loop counter to 24 ($18)?
				TXA 				; move psb to a
				BNE 	_BIT16			; if psb not 0 - jump to set loop counter to 16 ($10)?

					LDA 	ab07			; get lsb
					BEQ 	_BIT00 			; if lsb is 0 - jump to overflow and exit

						LDX 	#0
						STX 	ab07
						LDX 	#8			; set loop counter to 8?
						BNE 	_EXP_LOOP 		; jump?

_BIT24   	STX 	ab07	; store psb?
			LDX 	#24		; set loop counter to 24?

_EXP_LOOP     	DEX 			; find exponent - start from whatever x is passed in and reduce until x a bit set found 
				ASL 	ab07 	; shift lsb up into carry
				ROL 	 		; shift msb up with carry - mantisa?
				BCC 	_EXP_LOOP	; as soon as first bit is set then exit

			TAY					; store mantisa?
			TXA 				; x is exponent?
			ASL 				; exponent *2?
			ASL 	ab06		; shift msb putting sign into carry 
			ROL 				; rotate carry into first bit of exponent - bit 0 is sign
			RTS

_BIT16   	LDX 	#16		; set loop counter to 16?
			BNE 	_EXP_LOOP 	; jump?
		
_BIT00    	LDY 	#<OVERFLOW ; overflow?
			LDA 	#>OVERFLOW
			RTS 

SIN_COS	LDX 	ROT_LO
        LDY 	ROT_HI
        JSR 	SIN_FP
        STX 	SIN_LO ; sin_lo
        STY 	SIN_HI ; sin_hi
        LDX 	ROT_LO
        LDY 	ROT_HI
        JSR 	COS_FP
        STX 	COS_LO ; cos_lo
        STY 	COS_HI ; cos_hi
        RTS 

CLR_SCN	.macro
			STA \1+(\2*320)+0,Y
			STA \1+(\2*320)+1,Y
			STA \1+(\2*320)+2,Y
			STA \1+(\2*320)+3,Y
			STA \1+(\2*320)+4,Y
			STA \1+(\2*320)+5,Y
			STA \1+(\2*320)+6,Y
			STA \1+(\2*320)+7,Y
        .endm

DRAW_SCREEN	LDA		#$E0
WAIT_RASTER	CMP		$D012
			BNE 	WAIT_RASTER

			INC		SCREEN_FLIP		; INCREMENT SCREEN FLIP
			LDA		SCREEN_FLIP		; GET SCREEN FLIP
			LSR 					; SHIFT BIT0 INTO CARRY
			BCS		SCRN_2			; CARRY SET ?

			LDY		#SCREEN_0		; SCREEN 1 OFFSET
			lda		#>VER_POS_SCN0_HI
			LDX		#$78
			
			BNE		SCNCLR			; JUMP

SCRN_2  	LDY		#SCREEN_1		; SCREEN 2 OFFSET
			lda		#>VER_POS_SCN1_HI
			LDX		#$70

SCNCLR		STA		HEX_SCN_0 +2
			STA		HEX_SCN_1 +2
			STA		HEX_SCN_2 +2
			STA		HEX_SCN_3 +2
			STA		HEX_SCN_4 +2
			STX		VIC_SCREEN_BANK +1
			LDX 	#32
			CPY 	#SCREEN_1
			BNE	CLSSCN0_LP
				JMP CLSSCN1_LP

CLSSCN0_LP	LDA 	#255
			#CLR_SCN SCREEN0, 0
			#CLR_SCN SCREEN0, 1
			#CLR_SCN SCREEN0, 2
			#CLR_SCN SCREEN0, 3
			#CLR_SCN SCREEN0, 4
			#CLR_SCN SCREEN0, 5
			#CLR_SCN SCREEN0, 6
			#CLR_SCN SCREEN0, 7
			#CLR_SCN SCREEN0, 8
			#CLR_SCN SCREEN0, 9
			#CLR_SCN SCREEN0, 10
			#CLR_SCN SCREEN0, 11
			#CLR_SCN SCREEN0, 12
			#CLR_SCN SCREEN0, 13
			#CLR_SCN SCREEN0, 14
			#CLR_SCN SCREEN0, 15
			DEX
			BEQ 	CLSSCN0_END
				TYA
				CLC
				ADC	#8
				TAY
				JMP		CLSSCN0_LP
CLSSCN0_END	RTS

CLSSCN1_LP
			LDA 	#255
			#CLR_SCN SCREEN1, 0
			#CLR_SCN SCREEN1, 1
			#CLR_SCN SCREEN1, 2
			#CLR_SCN SCREEN1, 3
			#CLR_SCN SCREEN1, 4
			#CLR_SCN SCREEN1, 5
			#CLR_SCN SCREEN1, 6
			#CLR_SCN SCREEN1, 7
			#CLR_SCN SCREEN1, 8
			#CLR_SCN SCREEN1, 9
			#CLR_SCN SCREEN1, 10
			#CLR_SCN SCREEN1, 11
			#CLR_SCN SCREEN1, 12
			#CLR_SCN SCREEN1, 13
			#CLR_SCN SCREEN1, 14
			#CLR_SCN SCREEN1, 15
			DEX
			BEQ 	CLSSCN1_END
				TYA
				CLC
				ADC  #8
				TAY
				JMP 	CLSSCN1_LP
CLSSCN1_END	RTS

JOYSTICK
        LDA 	$DC00    ;CIA1: Data Port Register A into A and X
MVMENT	LSR
		BCS 	MVE_DWN
			PHA
			LDA 	CURR_Z_LSB
			CLC
			ADC 	INC_COUNT
			STA 	CURR_Z_LSB
			LDA 	CURR_Z_MSB
			ADC		#0
			STA 	CURR_Z_MSB
			LDA 	CURR_Z_HSB
			ADC		#0
			STA 	CURR_Z_HSB
			PLA
MVE_DWN LSR
		BCS 	MVE_LFT
			PHA
			LDA 	CURR_Z_LSB
			SEC
			SBC 	INC_COUNT
			STA 	CURR_Z_LSB
			LDA 	CURR_Z_MSB
			SBC		#0
			STA 	CURR_Z_MSB
			LDA 	CURR_Z_HSB
			SBC		#0
			STA 	CURR_Z_HSB
			PLA
MVE_LFT LSR
		BCS 	MVE_RGT
			PHA
			LDA 	CURR_X_LSB
			CLC
			ADC 	INC_COUNT
			STA 	CURR_X_LSB
			LDA 	CURR_X_MSB
			ADC		#0
			STA 	CURR_X_MSB
			LDA 	CURR_X_HSB
			ADC		#0
			STA 	CURR_X_HSB
			PLA
MVE_RGT LSR
		BCS 	MVE_FRE
			PHA
			LDA 	CURR_X_LSB
			SEC
			SBC 	INC_COUNT
			STA 	CURR_X_LSB
			LDA 	CURR_X_MSB
			SBC		#0
			STA 	CURR_X_MSB
			LDA 	CURR_X_HSB
			SBC		#0
			STA 	CURR_X_HSB
			PLA
MVE_FRE LSR
		BCS 	MVE_EXT
			lda 	INC_COUNT
			clc
			adc 	#1
			and 	#31
			sta 	INC_COUNT
MVE_EXT	RTS

HEXCHAR		LDA		HEX0,Y
HEX_NUMBER0	STA		$ABCD,X
			LDA		HEX1,Y
HEX_NUMBER1	STA		$ABCD,X
			LDA		HEX2,Y
HEX_NUMBER2	STA		$ABCD,X
			LDA		HEX3,Y
HEX_NUMBER3	STA		$ABCD,X
			LDA		HEX4,Y
HEX_NUMBER4	STA		$ABCD,X
			RTS

HEX16		STY		REGY	; Y = YPOS / A = HI / X = LO
			STX		REGX		
			LDX		#0
			JSR		HEX8
			LDA		REGX
			LDY		REGY
			LDX		#16
			JSR		HEX8
			RTS

HEX8		CLC		; A = NUM / Y = YPOS / X = XPOS

			STA		REGA
			LDA		VER_POS_LO+0,Y
			STA		HEX_NUMBER0+1
HEX_SCN_0	LDA 	VER_POS_SCN0_HI+0,Y
			STA		HEX_NUMBER0+2

			LDA		VER_POS_LO+1,Y
			STA		HEX_NUMBER1+1
HEX_SCN_1	LDA 	VER_POS_SCN0_HI+1,Y
			STA		HEX_NUMBER1+2

			LDA		VER_POS_LO+2,Y
			STA		HEX_NUMBER2+1			
HEX_SCN_2	LDA 	VER_POS_SCN0_HI+2,Y
			STA		HEX_NUMBER2+2

			LDA		VER_POS_LO+3,Y
			STA		HEX_NUMBER3+1			
HEX_SCN_3	LDA 	VER_POS_SCN0_HI+3,Y
			STA		HEX_NUMBER3+2

			LDA		VER_POS_LO+4,Y
			STA		HEX_NUMBER4+1
HEX_SCN_4	LDA 	VER_POS_SCN0_HI+4,Y
			STA		HEX_NUMBER4+2

			LDA		REGA
			LSR
			LSR
			LSR
			LSR
			TAY
			JSR		HEXCHAR

			TXA
			CLC
			ADC 	#8
			TAX

			LDA		REGA
			AND		#15
			TAY
			JSR		HEXCHAR

			RTS

HEX0	.BYTE %11000000,%11110011,%11000000,%11000000,%11001100,%11000000,%11000000,%11000000,%11000000,%11000000,%11000000,%11000000,%11000000,%11000011,%11000000,%11000000 
HEX1	.BYTE %11001100,%11000011,%11111100,%11111100,%11001100,%11001111,%11001111,%11111100,%11001100,%11001100,%11001100,%11001100,%11001111,%11001100,%11001111,%11001111 
HEX2	.BYTE %11001100,%11110011,%11000000,%11000000,%11000000,%11000000,%11000000,%11111100,%11000000,%11000000,%11000000,%11000011,%11001111,%11001100,%11000000,%11000000
HEX3	.BYTE %11001100,%11110011,%11001111,%11111100,%11111100,%11111100,%11001100,%11111100,%11001100,%11111100,%11001100,%11001100,%11001111,%11001100,%11001111,%11001111
HEX4	.BYTE %11000000,%11000000,%11000000,%11000000,%11111100,%11000000,%11000000,%11111100,%11000000,%11000000,%11001100,%11000000,%11000000,%11000011,%11000000,%11001111
	
.ALIGN $100
SIN_LSB
		.BYTE $92,$2E,$F7,$60,$C4,$14,$47,$79
        .BYTE $AB,$DD,$08,$21,$3A,$53,$6C,$85
        .BYTE $9E,$B7,$D0,$E9,$01,$0D,$1A,$26
        .BYTE $33,$3F,$4C,$58,$64,$71,$7D,$89
        .BYTE $96,$A2,$AE,$BB,$C7,$D3,$DF,$EC
        .BYTE $F8,$02,$08,$0E,$14,$1A,$20,$26
        .BYTE $2C,$32,$38,$3E,$44,$4A,$50,$56
        .BYTE $5C,$62,$68,$6E,$73,$79,$7F,$85
        .BYTE $8B,$91,$96,$9C,$A2,$A8,$AD,$B3
        .BYTE $B9,$BE,$C4,$CA,$CF,$D5,$DA,$E0
        .BYTE $E5,$EB,$F1,$F6,$FB,$00,$03,$06
        .BYTE $09,$0B,$0E,$11,$13,$16,$19,$1B
        .BYTE $1E,$20,$23,$26,$28,$2B,$2D,$30
        .BYTE $32,$35,$37,$3A,$3C,$3F,$41,$44
        .BYTE $46,$48,$4B,$4D,$50,$52,$54,$57
        .BYTE $59,$5B,$5E,$60,$62,$64,$67,$69
        .BYTE $6B,$6D,$70,$72,$74,$76,$78,$7A
        .BYTE $7C,$7F,$81,$83,$85,$87,$89,$8B
        .BYTE $8D,$8F,$91,$93,$95,$97,$98,$9A
        .BYTE $9C,$9E,$A0,$A2,$A4,$A5,$A7,$A9
        .BYTE $AB,$AC,$AE,$B0,$B1,$B3,$B5,$B6
        .BYTE $B8,$BA,$BB,$BD,$BE,$C0,$C1,$C3
        .BYTE $C4,$C6,$C7,$C9,$CA,$CB,$CD,$CE
        .BYTE $D0,$D1,$D2,$D3,$D5,$D6,$D7,$D8
        .BYTE $DA,$DB,$DC,$DD,$DE,$DF,$E0,$E2
        .BYTE $E3,$E4,$E5,$E6,$E7,$E8,$E9,$E9
        .BYTE $EA,$EB,$EC,$ED,$EE,$EF,$EF,$F0
        .BYTE $F1,$F2,$F3,$F3,$F4,$F5,$F5,$F6
        .BYTE $F6,$F7,$F8,$F8,$F9,$F9,$FA,$FA
        .BYTE $FB,$FB,$FC,$FC,$FC,$FD,$FD,$FD
        .BYTE $FE,$FE,$FE,$FE,$FF,$FF,$FF,$FF
        .BYTE $FF,$00,$00,$00,$00,$00,$00,$00
 
SIN_MSB
		.BYTE $DC,$E4,$E4,$E8,$E8,$EC,$EC,$EC
        .BYTE $EC,$EC,$F0,$F0,$F0,$F0,$F0,$F0
        .BYTE $F0,$F0,$F0,$F0,$F4,$F4,$F4,$F4
        .BYTE $F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4
        .BYTE $F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4
        .BYTE $F4,$F8,$F8,$F8,$F8,$F8,$F8,$F8
        .BYTE $F8,$F8,$F8,$F8,$F8,$F8,$F8,$F8
        .BYTE $F8,$F8,$F8,$F8,$F8,$F8,$F8,$F8
        .BYTE $F8,$F8,$F8,$F8,$F8,$F8,$F8,$F8
        .BYTE $F8,$F8,$F8,$F8,$F8,$F8,$F8,$F8
        .BYTE $F8,$F8,$F8,$F8,$F8,$FC,$FC,$FC
        .BYTE $FC,$FC,$FC,$FC,$FC,$FC,$FC,$FC
        .BYTE $FC,$FC,$FC,$FC,$FC,$FC,$FC,$FC
        .BYTE $FC,$FC,$FC,$FC,$FC,$FC,$FC,$FC
        .BYTE $FC,$FC,$FC,$FC,$FC,$FC,$FC,$FC
        .BYTE $FC,$FC,$FC,$FC,$FC,$FC,$FC,$FC
        .BYTE $FC,$FC,$FC,$FC,$FC,$FC,$FC,$FC
        .BYTE $FC,$FC,$FC,$FC,$FC,$FC,$FC,$FC
        .BYTE $FC,$FC,$FC,$FC,$FC,$FC,$FC,$FC
        .BYTE $FC,$FC,$FC,$FC,$FC,$FC,$FC,$FC
        .BYTE $FC,$FC,$FC,$FC,$FC,$FC,$FC,$FC
        .BYTE $FC,$FC,$FC,$FC,$FC,$FC,$FC,$FC
        .BYTE $FC,$FC,$FC,$FC,$FC,$FC,$FC,$FC
        .BYTE $FC,$FC,$FC,$FC,$FC,$FC,$FC,$FC
        .BYTE $FC,$FC,$FC,$FC,$FC,$FC,$FC,$FC
        .BYTE $FC,$FC,$FC,$FC,$FC,$FC,$FC,$FC
        .BYTE $FC,$FC,$FC,$FC,$FC,$FC,$FC,$FC
        .BYTE $FC,$FC,$FC,$FC,$FC,$FC,$FC,$FC
        .BYTE $FC,$FC,$FC,$FC,$FC,$FC,$FC,$FC
        .BYTE $FC,$FC,$FC,$FC,$FC,$FC,$FC,$FC
        .BYTE $FC,$FC,$FC,$FC,$FC,$FC,$FC,$FC
        .BYTE $FC,$00,$00,$00,$00,$00,$00,$00
	
	
LOG_TABLE:										; x = int(0.5 +log2(1 + x/256) * 256)
		.BYTE $00,$01,$03,$04,$06,$07,$09,$0A
        .BYTE $0B,$0D,$0E,$10,$11,$12,$14,$15
        .BYTE $16,$18,$19,$1A,$1C,$1D,$1E,$20
        .BYTE $21,$22,$24,$25,$26,$28,$29,$2A
        .BYTE $2C,$2D,$2E,$2F,$31,$32,$33,$34
        .BYTE $36,$37,$38,$39,$3B,$3C,$3D,$3E
        .BYTE $3F,$41,$42,$43,$44,$45,$47,$48
        .BYTE $49,$4A,$4B,$4D,$4E,$4F,$50,$51
        .BYTE $52,$54,$55,$56,$57,$58,$59,$5A
        .BYTE $5C,$5D,$5E,$5F,$60,$61,$62,$63
        .BYTE $64,$66,$67,$68,$69,$6A,$6B,$6C
        .BYTE $6D,$6E,$6F,$70,$71,$72,$74,$75
        .BYTE $76,$77,$78,$79,$7A,$7B,$7C,$7D
        .BYTE $7E,$7F,$80,$81,$82,$83,$84,$85
        .BYTE $86,$87,$88,$89,$8A,$8B,$8C,$8D
        .BYTE $8E,$8F,$90,$91,$92,$93,$94,$95
        .BYTE $96,$97,$98,$99,$9A,$9B,$9B,$9C
        .BYTE $9D,$9E,$9F,$A0,$A1,$A2,$A3,$A4
        .BYTE $A5,$A6,$A7,$A8,$A9,$A9,$AA,$AB
        .BYTE $AC,$AD,$AE,$AF,$B0,$B1,$B2,$B2
        .BYTE $B3,$B4,$B5,$B6,$B7,$B8,$B9,$B9
        .BYTE $BA,$BB,$BC,$BD,$BE,$BF,$C0,$C0
        .BYTE $C1,$C2,$C3,$C4,$C5,$C6,$C6,$C7
        .BYTE $C8,$C9,$CA,$CB,$CB,$CC,$CD,$CE
        .BYTE $CF,$D0,$D0,$D1,$D2,$D3,$D4,$D4
        .BYTE $D5,$D6,$D7,$D8,$D8,$D9,$DA,$DB
        .BYTE $DC,$DC,$DD,$DE,$DF,$E0,$E0,$E1
        .BYTE $E2,$E3,$E4,$E4,$E5,$E6,$E7,$E7
        .BYTE $E8,$E9,$EA,$EA,$EB,$EC,$ED,$EE
        .BYTE $EE,$EF,$F0,$F1,$F1,$F2,$F3,$F4
        .BYTE $F4,$F5,$F6,$F7,$F7,$F8,$F9,$F9
        .BYTE $FA,$FB,$FC,$FC,$FD,$FE,$FF,$FF

EXP_TABLE:										; x = int(0.5 + (2^(x/256) -1) *256)
		.BYTE $00,$01,$01,$02,$03,$03,$04,$05
        .BYTE $06,$06,$07,$08,$08,$09,$0A,$0B
        .BYTE $0B,$0C,$0D,$0E,$0E,$0F,$10,$10
        .BYTE $11,$12,$13,$13,$14,$15,$16,$16
        .BYTE $17,$18,$19,$19,$1A,$1B,$1C,$1D
        .BYTE $1D,$1E,$1F,$20,$20,$21,$22,$23
        .BYTE $24,$24,$25,$26,$27,$28,$28,$29
        .BYTE $2A,$2B,$2C,$2C,$2D,$2E,$2F,$30
        .BYTE $30,$31,$32,$33,$34,$35,$35,$36
        .BYTE $37,$38,$39,$3A,$3A,$3B,$3C,$3D
        .BYTE $3E,$3F,$40,$41,$41,$42,$43,$44
        .BYTE $45,$46,$47,$48,$48,$49,$4A,$4B
        .BYTE $4C,$4D,$4E,$4F,$50,$51,$51,$52
        .BYTE $53,$54,$55,$56,$57,$58,$59,$5A
        .BYTE $5B,$5C,$5D,$5E,$5E,$5F,$60,$61
        .BYTE $62,$63,$64,$65,$66,$67,$68,$69
        .BYTE $6A,$6B,$6C,$6D,$6E,$6F,$70,$71
        .BYTE $72,$73,$74,$75,$76,$77,$78,$79
        .BYTE $7A,$7B,$7C,$7D,$7E,$7F,$80,$81
        .BYTE $82,$83,$84,$85,$87,$88,$89,$8A
        .BYTE $8B,$8C,$8D,$8E,$8F,$90,$91,$92
        .BYTE $93,$95,$96,$97,$98,$99,$9A,$9B
        .BYTE $9C,$9D,$9F,$A0,$A1,$A2,$A3,$A4
        .BYTE $A5,$A6,$A8,$A9,$AA,$AB,$AC,$AD
        .BYTE $AF,$B0,$B1,$B2,$B3,$B4,$B6,$B7
        .BYTE $B8,$B9,$BA,$BC,$BD,$BE,$BF,$C0
        .BYTE $C2,$C3,$C4,$C5,$C6,$C8,$C9,$CA
        .BYTE $CB,$CD,$CE,$CF,$D0,$D2,$D3,$D4
        .BYTE $D6,$D7,$D8,$D9,$DB,$DC,$DD,$DE
        .BYTE $E0,$E1,$E2,$E4,$E5,$E6,$E8,$E9
        .BYTE $EA,$EC,$ED,$EE,$F0,$F1,$F2,$F4
        .BYTE $F5,$F6,$F8,$F9,$FA,$FC,$FD,$FF

.ALIGN $100
VER_POS_SCN0_HI
		.BYTE (>SCREEN0)+$00,(>SCREEN0)+$00,(>SCREEN0)+$00,(>SCREEN0)+$00,(>SCREEN0)+$00,(>SCREEN0)+$00,(>SCREEN0)+$00,(>SCREEN0)+$00
        .BYTE (>SCREEN0)+$01,(>SCREEN0)+$01,(>SCREEN0)+$01,(>SCREEN0)+$01,(>SCREEN0)+$01,(>SCREEN0)+$01,(>SCREEN0)+$01,(>SCREEN0)+$01
        .BYTE (>SCREEN0)+$02,(>SCREEN0)+$02,(>SCREEN0)+$02,(>SCREEN0)+$02,(>SCREEN0)+$02,(>SCREEN0)+$02,(>SCREEN0)+$02,(>SCREEN0)+$02
        .BYTE (>SCREEN0)+$03,(>SCREEN0)+$03,(>SCREEN0)+$03,(>SCREEN0)+$03,(>SCREEN0)+$03,(>SCREEN0)+$03,(>SCREEN0)+$03,(>SCREEN0)+$03
        .BYTE (>SCREEN0)+$05,(>SCREEN0)+$05,(>SCREEN0)+$05,(>SCREEN0)+$05,(>SCREEN0)+$05,(>SCREEN0)+$05,(>SCREEN0)+$05,(>SCREEN0)+$05
        .BYTE (>SCREEN0)+$06,(>SCREEN0)+$06,(>SCREEN0)+$06,(>SCREEN0)+$06,(>SCREEN0)+$06,(>SCREEN0)+$06,(>SCREEN0)+$06,(>SCREEN0)+$06
        .BYTE (>SCREEN0)+$07,(>SCREEN0)+$07,(>SCREEN0)+$07,(>SCREEN0)+$07,(>SCREEN0)+$07,(>SCREEN0)+$07,(>SCREEN0)+$07,(>SCREEN0)+$07
        .BYTE (>SCREEN0)+$08,(>SCREEN0)+$08,(>SCREEN0)+$08,(>SCREEN0)+$08,(>SCREEN0)+$08,(>SCREEN0)+$08,(>SCREEN0)+$08,(>SCREEN0)+$08
        .BYTE (>SCREEN0)+$0A,(>SCREEN0)+$0A,(>SCREEN0)+$0A,(>SCREEN0)+$0A,(>SCREEN0)+$0A,(>SCREEN0)+$0A,(>SCREEN0)+$0A,(>SCREEN0)+$0A
        .BYTE (>SCREEN0)+$0B,(>SCREEN0)+$0B,(>SCREEN0)+$0B,(>SCREEN0)+$0B,(>SCREEN0)+$0B,(>SCREEN0)+$0B,(>SCREEN0)+$0B,(>SCREEN0)+$0B
        .BYTE (>SCREEN0)+$0C,(>SCREEN0)+$0C,(>SCREEN0)+$0C,(>SCREEN0)+$0C,(>SCREEN0)+$0C,(>SCREEN0)+$0C,(>SCREEN0)+$0C,(>SCREEN0)+$0C
        .BYTE (>SCREEN0)+$0D,(>SCREEN0)+$0D,(>SCREEN0)+$0D,(>SCREEN0)+$0D,(>SCREEN0)+$0D,(>SCREEN0)+$0D,(>SCREEN0)+$0D,(>SCREEN0)+$0D
        .BYTE (>SCREEN0)+$0F,(>SCREEN0)+$0F,(>SCREEN0)+$0F,(>SCREEN0)+$0F,(>SCREEN0)+$0F,(>SCREEN0)+$0F,(>SCREEN0)+$0F,(>SCREEN0)+$0F
        .BYTE (>SCREEN0)+$10,(>SCREEN0)+$10,(>SCREEN0)+$10,(>SCREEN0)+$10,(>SCREEN0)+$10,(>SCREEN0)+$10,(>SCREEN0)+$10,(>SCREEN0)+$10
        .BYTE (>SCREEN0)+$11,(>SCREEN0)+$11,(>SCREEN0)+$11,(>SCREEN0)+$11,(>SCREEN0)+$11,(>SCREEN0)+$11,(>SCREEN0)+$11,(>SCREEN0)+$11
        .BYTE (>SCREEN0)+$12,(>SCREEN0)+$12,(>SCREEN0)+$12,(>SCREEN0)+$12,(>SCREEN0)+$12,(>SCREEN0)+$12,(>SCREEN0)+$12,(>SCREEN0)+$12

.ALIGN $100
VER_POS_SCN1_HI
		.BYTE (>SCREEN1)+$00,(>SCREEN1)+$00,(>SCREEN1)+$00,(>SCREEN1)+$00,(>SCREEN1)+$00,(>SCREEN1)+$00,(>SCREEN1)+$00,(>SCREEN1)+$00
        .BYTE (>SCREEN1)+$01,(>SCREEN1)+$01,(>SCREEN1)+$01,(>SCREEN1)+$01,(>SCREEN1)+$01,(>SCREEN1)+$01,(>SCREEN1)+$01,(>SCREEN1)+$01
        .BYTE (>SCREEN1)+$02,(>SCREEN1)+$02,(>SCREEN1)+$02,(>SCREEN1)+$02,(>SCREEN1)+$02,(>SCREEN1)+$02,(>SCREEN1)+$02,(>SCREEN1)+$02
        .BYTE (>SCREEN1)+$03,(>SCREEN1)+$03,(>SCREEN1)+$03,(>SCREEN1)+$03,(>SCREEN1)+$03,(>SCREEN1)+$03,(>SCREEN1)+$03,(>SCREEN1)+$03
        .BYTE (>SCREEN1)+$05,(>SCREEN1)+$05,(>SCREEN1)+$05,(>SCREEN1)+$05,(>SCREEN1)+$05,(>SCREEN1)+$05,(>SCREEN1)+$05,(>SCREEN1)+$05
        .BYTE (>SCREEN1)+$06,(>SCREEN1)+$06,(>SCREEN1)+$06,(>SCREEN1)+$06,(>SCREEN1)+$06,(>SCREEN1)+$06,(>SCREEN1)+$06,(>SCREEN1)+$06
        .BYTE (>SCREEN1)+$07,(>SCREEN1)+$07,(>SCREEN1)+$07,(>SCREEN1)+$07,(>SCREEN1)+$07,(>SCREEN1)+$07,(>SCREEN1)+$07,(>SCREEN1)+$07
        .BYTE (>SCREEN1)+$08,(>SCREEN1)+$08,(>SCREEN1)+$08,(>SCREEN1)+$08,(>SCREEN1)+$08,(>SCREEN1)+$08,(>SCREEN1)+$08,(>SCREEN1)+$08
        .BYTE (>SCREEN1)+$0A,(>SCREEN1)+$0A,(>SCREEN1)+$0A,(>SCREEN1)+$0A,(>SCREEN1)+$0A,(>SCREEN1)+$0A,(>SCREEN1)+$0A,(>SCREEN1)+$0A
        .BYTE (>SCREEN1)+$0B,(>SCREEN1)+$0B,(>SCREEN1)+$0B,(>SCREEN1)+$0B,(>SCREEN1)+$0B,(>SCREEN1)+$0B,(>SCREEN1)+$0B,(>SCREEN1)+$0B
        .BYTE (>SCREEN1)+$0C,(>SCREEN1)+$0C,(>SCREEN1)+$0C,(>SCREEN1)+$0C,(>SCREEN1)+$0C,(>SCREEN1)+$0C,(>SCREEN1)+$0C,(>SCREEN1)+$0C
        .BYTE (>SCREEN1)+$0D,(>SCREEN1)+$0D,(>SCREEN1)+$0D,(>SCREEN1)+$0D,(>SCREEN1)+$0D,(>SCREEN1)+$0D,(>SCREEN1)+$0D,(>SCREEN1)+$0D
        .BYTE (>SCREEN1)+$0F,(>SCREEN1)+$0F,(>SCREEN1)+$0F,(>SCREEN1)+$0F,(>SCREEN1)+$0F,(>SCREEN1)+$0F,(>SCREEN1)+$0F,(>SCREEN1)+$0F
        .BYTE (>SCREEN1)+$10,(>SCREEN1)+$10,(>SCREEN1)+$10,(>SCREEN1)+$10,(>SCREEN1)+$10,(>SCREEN1)+$10,(>SCREEN1)+$10,(>SCREEN1)+$10
        .BYTE (>SCREEN1)+$11,(>SCREEN1)+$11,(>SCREEN1)+$11,(>SCREEN1)+$11,(>SCREEN1)+$11,(>SCREEN1)+$11,(>SCREEN1)+$11,(>SCREEN1)+$11
        .BYTE (>SCREEN1)+$12,(>SCREEN1)+$12,(>SCREEN1)+$12,(>SCREEN1)+$12,(>SCREEN1)+$12,(>SCREEN1)+$12,(>SCREEN1)+$12,(>SCREEN1)+$12

VER_POS_LO
		.BYTE $00,$01,$02,$03,$04,$05,$06,$07
        .BYTE $40,$41,$42,$43,$44,$45,$46,$47
        .BYTE $80,$81,$82,$83,$84,$85,$86,$87
        .BYTE $C0,$C1,$C2,$C3,$C4,$C5,$C6,$C7
        .BYTE $00,$01,$02,$03,$04,$05,$06,$07
        .BYTE $40,$41,$42,$43,$44,$45,$46,$47
        .BYTE $80,$81,$82,$83,$84,$85,$86,$87
		.BYTE $C0,$C1,$C2,$C3,$C4,$C5,$C6,$C7
		.BYTE $00,$01,$02,$03,$04,$05,$06,$07
		.BYTE $40,$41,$42,$43,$44,$45,$46,$47
		.BYTE $80,$81,$82,$83,$84,$85,$86,$87
		.BYTE $C0,$C1,$C2,$C3,$C4,$C5,$C6,$C7
		.BYTE $00,$01,$02,$03,$04,$05,$06,$07
		.BYTE $40,$41,$42,$43,$44,$45,$46,$47
		.BYTE $80,$81,$82,$83,$84,$85,$86,$87
		.BYTE $C0,$C1,$C2,$C3,$C4,$C5,$C6,$C7
		.BYTE $00,$01,$02,$03,$04,$05,$06,$07

HOR_SCR_POS
		.BYTE $00,$00,$00,$00,$08,$08,$08,$08
        .BYTE $10,$10,$10,$10,$18,$18,$18,$18
        .BYTE $20,$20,$20,$20,$28,$28,$28,$28
        .BYTE $30,$30,$30,$30,$38,$38,$38,$38
        .BYTE $40,$40,$40,$40,$48,$48,$48,$48
        .BYTE $50,$50,$50,$50,$58,$58,$58,$58
        .BYTE $60,$60,$60,$60,$68,$68,$68,$68
        .BYTE $70,$70,$70,$70,$78,$78,$78,$78
        .BYTE $80,$80,$80,$80,$88,$88,$88,$88
        .BYTE $90,$90,$90,$90,$98,$98,$98,$98
        .BYTE $A0,$A0,$A0,$A0,$A8,$A8,$A8,$A8
        .BYTE $B0,$B0,$B0,$B0,$B8,$B8,$B8,$B8
        .BYTE $C0,$C0,$C0,$C0,$C8,$C8,$C8,$C8
        .BYTE $D0,$D0,$D0,$D0,$D8,$D8,$D8,$D8
        .BYTE $E0,$E0,$E0,$E0,$E8,$E8,$E8,$E8
        .BYTE $F0,$F0,$F0,$F0,$F8,$F8,$F8,$F8

SCREEN0 = $4000
SCREEN_COLOUR =  $5C00
SCREEN1 = $6000
