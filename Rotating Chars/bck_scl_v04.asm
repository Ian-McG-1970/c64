; uses vic bank 49152-65535
; 63k to 64k = unavailable
; 60k to 62k = charset
; 58k to 59k = screen

; could be 63k = bb / 62k = scn / 60k = charset


; bank = 16384-32767
; screen = 29k
; charset = 30k-32k

; rotated charset = 2 chars down by 2 char acrosss = 32byttes X 1.5 = 46bytes X 16 rotations hor = 768 bytes
; 63k

SCN = 2
SCN_LO = SCN
SCN_HI = SCN_LO +1
SRC = SCN +2
DST = SRC +2
MEM_SIZE = DST +2
MEM_SIZE_LO = MEM_SIZE
MEM_SIZE_HI = MEM_SIZE +1

REGA = MEM_SIZE +2
REGX = REGA +1
REGY = REGX +1
PLAYER_H = REGY +1
PLAYER_V = PLAYER_H +1

VPIX = PLAYER_V +1
HPIX = VPIX +1

BORDER = $D020
SCRCOL0 = $D021
SCRCOL1 = $D022
SCRCOL2 = $D023
SCRCOL3 = $D024

MP_RASTER_POS = 246-6

VIC_SCN = 29*1024
VIC_CHAR_SET = 30*1024

SPRENBL = 53248+21
SPRMULTI = $D01C
SPRPRI = $D01B

SPRXPX = 53248+29 
SPRXPY = 53248+23

S0X = 53248+0
S0Y = 53248+1
S0C = $D027

S1X = 53248+2
S1Y = 53248+3
S1C = $D028

S2X = 53248+4
S2Y = 53248+5
S2C = $D029

S3X = 53248+6
S3Y = 53248+7
S3C = $D02A

S4X = 53248+8
S4Y = 53248+9
S4C = $D02B

S5X = 53248+10
S5Y = 53248+11
S5C = $D02C

S6X = 53248+12
S6Y = 53248+13
S6C = $D02D

S7X = 53248+14
S7Y = 53248+15
S7C = $D02E

SPRXMSB = 53248+16
SPRBCKCOL = $D01F

SPRDEF0 = VIC_SCN +1016
SPRDEF1 = SPRDEF0 +1
SPRDEF2 = SPRDEF1 +1
SPRDEF3 = SPRDEF2 +1
SPRDEF4 = SPRDEF3 +1
SPRDEF5 = SPRDEF4 +1
SPRDEF6 = SPRDEF5 +1
SPRDEF7 = SPRDEF6 +1
   
CHAR_00 = VIC_CHAR_SET +(8*0)
CHAR_01 = VIC_CHAR_SET +(8*1)
CHAR_02 = VIC_CHAR_SET +(8*2)
CHAR_03 = VIC_CHAR_SET +(8*3)
CHAR_04 = VIC_CHAR_SET +(8*4)
CHAR_05 = VIC_CHAR_SET +(8*5)

;START
*= 2049
!byte $0c,$08,$0a,$00,$9e   ; Line 10 SYS
!tx "2070"            ; Address for sys start in text 4096+11

*= 2070

  SEI        ; disable maskable IRQs
  CLV
  CLD
  LDX   #$FF   ; reset stack
  TXS
 
  LDA   #$7F
  STA   $DC0D  ; disable timer interrupts which can be generated by the two CIA chips
  STA   $DD0D  ; the kernal uses such an interrupt to flash the cursor and scan the keyboard, so we better stop it.

  LDA   $DC0D  ; by reading this two registers we negate any pending CIA irqs.
  LDA   $DD0D  ; if we don't do this, a pending CIA irq might occur after we finish setting up our irq. we don't want that to happen.

  LDA   #$01   ; this is how to tell the VICII to generate a raster interrupt
  STA   $D01A

  LDA   #%00011011 ; $10 
  STA   $D011 ; #7: Read: Current raster line (bit #8) / #6: 1 = Extended background mode on / #5: 0 = Text mode; 1 = Bitmap mode / #4: 0 = Screen off, complete screen is covered by border; 1 = Screen on, normal screen contents are visible / #3: Screen height; 0 = 24 rows; 1 = 25 rows / #0-#2: Vertical raster scroll.
  LDA   #%00011000 ; %00011000 ; %00011000
  STA   $D016 ; #4: 1 = Multicolor mode on / #3: Screen width; 0 = 38 columns; 1 = 40 columns / #0-#2: Horizontal raster scroll.

  LDA   #$35   ; we turn off the BASIC and KERNAL rom here so cpu now sees RAM everywhere except $d000-$e000
  STA   $01

  LDA   #<MP_IRQ  ; interrupt code
  STA   $FFFE
  LDA   #>MP_IRQ
  STA   $FFFF
  LDA   #MP_RASTER_POS   ; this is how to tell at which rasterline we want the irq to be triggered
  STA   $D012

  LDA   #<NMI_NOP ; lsb
  STA   $FFFA ; Create a nop, irq handler for NMI that gets called whenever RESTORE is pressed or similar.
  LDA   #>NMI_NOP ; msb
  STA   $FFFB ; We're putting our irq handler directly in the vector that usually points to the kernal's NMI handler since we have kernal banked out.

  LDA   #$00  ; Force an NMI by setting up a timer. This will cause an NMI, that won't be acked. Any subsequent NMI's from RESTORE will be essentially disabled.
  STA   $DD0E       ; Stop timer A
  STA   $DD04       ; Set timer A to 0, NMI will occure immediately after start
  STA   $DD0E

  LDA   #$81
  STA   $DD0D       ; Set timer A as source for NMI

  LDA   #$01
  STA   $DD0E       ; Start timer A -> NMI

  LDA #%00000010 ; bank 1 (16384-32767)
  STA $DD00

;  LDA #%10101100 ; screen = $2800 + 48k = 58k / char = $3000 + 48k = 60k ;  LDA #%10111100 ; screen = $2C00 + 48k = 59k / char = $3000 + 48k = 60k
  LDA #%00001111 + %11010000  ; charset = %00001111 / screen = %11010000
  STA $D018

  LDA #0
  STA BORDER

  LDA #1
  STA SCRCOL0
  LDA #4
  STA SCRCOL1
  LDA #6
  STA SCRCOL2

  LDA #255
  STA SPRENBL
  STA SPRPRI
  
  LDA #0
  STA SPRMULTI
;  STA SPRPRI
  STA SPRXPX
  STA SPRXPY
  STA SPRXMSB

  LDA #0
  STA SPRDEF0
  STA SPRDEF1
  STA SPRDEF2
  STA SPRDEF3
  STA SPRDEF4
  STA SPRDEF5
  STA SPRDEF6
  STA SPRDEF7

  LDA #255
  LDX #<16384
  LDY #>16384
  STX DST +0
  STY DST +1
  LDX #>63 
  LDY #<63
  JSR MEMSET
   
  JSR SETUP_CHARS
  
  LDA #24
  STA S0X
  LDA #50
  STA S0Y
  STA S0C

  LDA #24
  STA S1X
  LDA #74
  STA S1Y
  STA S1C

  LDA #98
  STA S2X
  STA S2Y
  STA S2C

  LDA #24
  STA S3X
  LDA #120
  STA S3Y
  STA S3C

  LDA #142
  STA S4X
  STA S4Y
  STA S4C

  LDA #164
  STA S5X
  STA S5Y
  STA S5C

  LDA #186
  STA S6X
  LDA #200+24+5
  STA S6Y
  STA S6C

  LDA #255
  STA S7X
  LDA #200+24+5
  STA S7Y
  STA S7C

  LDA #50
  STA PLAYER_H
  STA PLAYER_V
  
 LDA #8+2 ; 3 ; 10 ; colour 11
 LDX #<$D800
 LDY #>$D800
 STX DST +0
 STY DST +1
 LDX #>1000 
 LDY #<1000
 JSR MEMSET

 LDA #0 ; screen
 LDX #<VIC_SCN
 LDY #>VIC_SCN
 STX DST +0
 STY DST +1
 LDX #>1000 
 LDY #<1000
 JSR MEMSET
 
 LDA #2
 STA VIC_SCN +160
 LDA #3
 STA VIC_SCN +200
 LDA #4
 STA VIC_SCN +161
 LDA #5
 STA VIC_SCN +201
 
 LDA #1
 STA VIC_SCN +400
; LDA #3 ; charset
; LDX #<VIC_CHAR_SET
; LDY #>VIC_CHAR_SET
; STX MEM_TO+0
; STY MEM_TO+1
; LDX #>2048 
; LDY #<2048
; JSR MEMSET
 
;  LDX #<2048
;  LDY #>2048
;  STX MEM_FROM+0
;  STY MEM_FROM+1
;  LDX #<VIC_CHAR_SET
;  LDY #>VIC_CHAR_SET
;  STX MEM_TO+0
;  STY MEM_TO+1
;  LDY #<2048
;  LDX #>2048
;  JSR MEMCPY

; lda #0 ; %11000110
; sta VIC_CHAR_SET +0
; sta VIC_CHAR_SET +1
; sta VIC_CHAR_SET +2
; sta VIC_CHAR_SET +3
; sta VIC_CHAR_SET +4
; sta VIC_CHAR_SET +5;
; sta VIC_CHAR_SET +;6
; sta VIC_CHAR_SET +7
 
  JSR SETUP_SCREEN
  JSR SETUP_BLOCKS
  
  CLI ; enable maskable interrupts again

MLOOP:  JMP   MLOOP ; we better don't RTS, the ROMS are now switched off, there's no way back to the system

;move memory down
;
; FROM = source start address
;   TO = destination start address
; SIZE = number of bytes to move
  
!ZONE MEMCPY
MEMCPY
    STY .LSB +1
    LDY #0
    TXA
    BEQ .LSB
.LOOPHI LDA (SRC),Y ; move a page at a time
        STA (DST),Y
        INY
        BNE .LOOPHI
      INC SRC +1
      INC DST +1
      DEX
      BNE .LOOPHI
.LSB    LDX #0
        BEQ .EXIT
.LOOPLO   LDA (SRC),Y ; move the remaining bytes
          STA (DST),Y
          INY
          DEX
          BNE .LOOPLO
.EXIT  RTS

!ZONE MEMSET        
MEMSET       STY    .LSB_ONLY+1 ; store LSB count
             CPX    #0          ; MSB?     
             BEQ    .LSB_ONLY   ; no

             LDY    #0          ; yes so reset LSB
.MSB_LOOP  
.LSB_LOOP      STA    (DST),Y   ; clear whole MSB
               DEY 
               BNE    .LSB_LOOP

              INC    DST+1      ; inc MSB
              DEX               ; dec MSB count
              BNE    .MSB_LOOP

.LSB_ONLY    LDY    #0          ; LSB count 
             BEQ    .MS_END     ; not needed

.LAST_LSB_LOOP STA   (DST),Y
               DEY 
               BNE   .LAST_LSB_LOOP
                
              STA   (DST),Y     ; clear last Y (0)
 
.MS_END      RTS

!ZONE MP_IRQ
MP_IRQ    INC   $D019    ;VIC Interrupt Request Register (IRR)
          STA   .REG_A+1
          STX   .REG_X+1
          STY   .REG_Y+1

 DEC BORDER

 INC BORDER
  JSR   JOYSTICK2
  JSR   MOVE_PLAYER ; move sprite
;  LDX PLAYER_V
;  LDY PLAYER_H
 
   LDA PLAYER_H
  LDY PLAYER_V
  JSR COPY_BLOCK_TO_CHARS ; _V2

 
 DEC BORDER

 INC BORDER
  
.REG_A     LDA   #0
.REG_X     LDX   #0
.REG_Y     LDY   #0
NMI_NOP:  RTI ; This is the irq handler for the NMI. Just returns without acknowledge. This prevents subsequent NMI's from interfering.

!ZONE JOYSTICK
JOYSTICK1 LDA $DC01
          BVC .JOYSTICK ; JMP
JOYSTICK2 LDA $DC00
.JOYSTICK LDX #0
          LDY #0
.UP       LSR
          BCS   .DOWN
            DEY
.DOWN     LSR
          BCS   .LEFT
            INY
.LEFT     LSR
          BCS   .RIGHT
            DEX
.RIGHT    LSR
          BCS   .FIRE
            INX
.FIRE     EOR   #255
          AND   #1
;          STA   JOYF
;          STX   JOYX
;          STY   JOYY
          LSR
          RTS

!ZONE MOVE_PLAYER
MOVE_PLAYER
    TXA
    BEQ   .VER
    BPL   .RIGHT
.LEFT   DEC   PLAYER_H
    BVC   .VER ; JMP
.RIGHT  INC   PLAYER_H
.VER    TYA
    BEQ   .EXIT
    BPL   .DOWN
.UP     DEC   PLAYER_V
    RTS
.DOWN   INC   PLAYER_V
.EXIT   RTS

!ZONE SETUP_CHARS
SETUP_CHARS
  LDA #0
  STA CHAR_00 +0
  STA CHAR_00 +1
  STA CHAR_00 +2
  STA CHAR_00 +3
  STA CHAR_00 +4
  STA CHAR_00 +5
  STA CHAR_00 +6
  STA CHAR_00 +7

  LDA #%10010110 ;255
  STA CHAR_01 +0
  STA CHAR_01 +1
  STA CHAR_01 +2
  STA CHAR_01 +3
  STA CHAR_01 +4
  STA CHAR_01 +5
  STA CHAR_01 +6
  STA CHAR_01 +7

  LDX #<BLOCK_TAB
  LDY #>BLOCK_TAB
  STX SRC +0
  STY SRC +1
  LDX #<CHAR_02
  LDY #>CHAR_02
  STX DST +0
  STY DST +1
  LDY #<32
  LDX #>32
  JSR MEMCPY
  RTS

!MACRO COPY_CHAR_LINE POS {
  LDA (SRC),Y ; position to 
  STA CHAR_02+POS
  LDA (DST),Y ; position to 
  STA CHAR_04+POS
}

; calculated as
;-00-16-
; 00 16
; 01 17
; 02 18
; 03 19
; 04 20
; 05 21
; 06 22
; 07 23
; 08 24
; 09 25
; 10 26
; 11 27
; 12 28
; 13 29
; 14 30
; 15 31

; needs to be
;-00-32-
; 00 16
; 01 17
; 02 18
; 03 19
; 04 20
; 05 21
; 06 22
; 07 23
; 08 24
; 09 25
; 10 26
; 11 27
; 12 28
; 13 29
; 14 30
; 15 31
; 00 16
; 01 17
; 02 18
; 03 19
; 04 20
; 05 21
; 06 22
; 07 23
; 08 24
; 09 25
; 10 26
; 11 27
; 12 28
; 13 29
; 14 30
; 15 31

!ZONE COPY_BLOCK_TO_CHARS
COPY_BLOCK_TO_CHARS

  AND #15
  TAX
  LDA BLOCK_BUFFER_TAB_LO,X
  STA SRC
  CLC
  ADC #32
  STA DST
;
  LDA BLOCK_BUFFER_TAB_HI,X
  STA SRC +1
  STA DST +1
;
  TYA
  AND #15
  TAY

  +COPY_CHAR_LINE 00
  INY
  +COPY_CHAR_LINE 01
  INY
  +COPY_CHAR_LINE 02
  INY
  +COPY_CHAR_LINE 03
  INY
  +COPY_CHAR_LINE 04
  INY
  +COPY_CHAR_LINE 05
  INY
  +COPY_CHAR_LINE 06
  INY
  +COPY_CHAR_LINE 07
  INY

  +COPY_CHAR_LINE 08
  INY
  +COPY_CHAR_LINE 09
  INY
  +COPY_CHAR_LINE 10
  INY
  +COPY_CHAR_LINE 11
  INY
  +COPY_CHAR_LINE 12
  INY
  +COPY_CHAR_LINE 13
  INY
  +COPY_CHAR_LINE 14
  INY
  +COPY_CHAR_LINE 15

  RTS

!ZONE BLOCK_SINGLE_SHIFT
BLOCK_SINGLE_SHIFT

  LDA CHAR_02,X
  ASL
  ROL CHAR_04,X
  ADC #0
; ASL
; ROL CHAR_04,Y
; ADC #0
  STA CHAR_02,X
  RTS

!ZONE BLOCK_SHIFT
BLOCK_SHIFT
  LDX #15
.LOOP
    JSR BLOCK_SINGLE_SHIFT
    JSR BLOCK_SINGLE_SHIFT
    DEX
    BPL .LOOP
  RTS

!ZONE SETUP_BLOCKS
SETUP_BLOCKS
  JSR BLOCK_SHIFT
  LDA #<BLOCK_BUFFER_00
  LDY #>BLOCK_BUFFER_00
  JSR BLOCK_COPY

  JSR BLOCK_SHIFT
  LDA #<BLOCK_BUFFER_01
  LDY #>BLOCK_BUFFER_01
  JSR BLOCK_COPY

  JSR BLOCK_SHIFT
  LDA #<BLOCK_BUFFER_02
  LDY #>BLOCK_BUFFER_02
  JSR BLOCK_COPY

  JSR BLOCK_SHIFT
  LDA #<BLOCK_BUFFER_03
  LDY #>BLOCK_BUFFER_03
  JSR BLOCK_COPY

  JSR BLOCK_SHIFT
  LDA #<BLOCK_BUFFER_04
  LDY #>BLOCK_BUFFER_04
  JSR BLOCK_COPY

  JSR BLOCK_SHIFT
  LDA #<BLOCK_BUFFER_05
  LDY #>BLOCK_BUFFER_05
  JSR BLOCK_COPY

  JSR BLOCK_SHIFT
  LDA #<BLOCK_BUFFER_06
  LDY #>BLOCK_BUFFER_06
  JSR BLOCK_COPY

  JSR BLOCK_SHIFT
  LDA #<BLOCK_BUFFER_07
  LDY #>BLOCK_BUFFER_07
;  JSR BLOCK_COPY
;  RTS

!ZONE BLOCK_COPY ; todo - needs to be finished
BLOCK_COPY
  STA SRC +0
  CLC
  ADC #16
  STA DST +0
  CLC
  ADC #16
  STA SCN +0
  CLC
  ADC #16
  STA MEM_SIZE +0
  
  STY SRC +1
  STY DST +1
  STY SCN +1
  STY MEM_SIZE +1
  
  LDY #15
.LOOP
    LDA CHAR_02,Y
    STA (SRC),Y
    STA (DST),Y
    LDA CHAR_04,Y
    STA (SCN),Y
    STA (MEM_SIZE),Y
    DEY
    BPL .LOOP
  RTS

!ZONE PLOT
PLOT
  STA REGA
  LDA VIC_SCN_LO,X
  STA SCN
  LDA VIC_SCN_HI,X
  STA SCN+1
  LDA REGA
  STA (SCN),Y
  RTS

!ZONE SETUP_SCREEN
SETUP_SCREEN
	LDY #28
.LOOP_O
		LDX #25
.LOOP_I
			TXA
			AND #1
			STA SCN
			TYA
			AND #1
			ASL
			ADC SCN
			ADC #2
			JSR PLOT
			DEX
			BPL .LOOP_I
		DEY
		BPL .LOOP_O

	LDX #25
.LOOP_X
		LDY #29
.LOOP_Y
			LDA #1
			JSR PLOT
			INY
			CPY #32
			BNE .LOOP_Y
		DEX
		BPL .LOOP_X
	RTS

VIC_SCN_LO
!for I = 0 TO 24
!BYTE <(VIC_SCN+(I*40))
!end

!align 255,0
VIC_CHAR_TAB_HI
!for I = 0 TO 255
!BYTE >(VIC_CHAR_SET+(I*8))
!end
  
VIC_CHAR_TAB_LO
!for I = 0 TO 255
!BYTE <(VIC_CHAR_SET+(I*8))
!end

VIC_SCN_HI
!for I = 0 TO 24
!BYTE >(VIC_SCN+(I*40))
!end

!align 255,0
H_PIXEL:
!for I = 0 TO 39
!BYTE 0,1,2,3,4,5,6,7
!end

!align 255,0
BLOCK_TAB
;!BYTE %11111111,%11111111
;!BYTE %11010101,%01010111
;!BYTE %11011010,%10100111
;!BYTE %11011000,%00100111
;!BYTE %11011000,%00100111
;!BYTE %11011000,%00100111
;!BYTE %11011000,%00100111
;!BYTE %11011000,%00100111
;!BYTE %11011000,%00100111
;!BYTE %11011000,%00100111
;!BYTE %11011000,%00100111
;!BYTE %11011000,%00100111
;!BYTE %11011000,%00100111
;!BYTE %11011010,%10100111
;!BYTE %11010101,%01010111
;!BYTE %11111111,%11111111

!BYTE %11111111
!BYTE %11010101
!BYTE %11011010
!BYTE %11011000
!BYTE %11011000
!BYTE %11011000
!BYTE %11011000
!BYTE %11011000
!BYTE %11011000
!BYTE %11011000
!BYTE %11011000
!BYTE %11011000
!BYTE %11011000
!BYTE %11011010
!BYTE %11010101
!BYTE %11111111

!BYTE %11111111
!BYTE %01010111
!BYTE %10100111
!BYTE %00100111
!BYTE %00100111
!BYTE %00100111
!BYTE %00100111
!BYTE %00100111
!BYTE %00100111
!BYTE %00100111
!BYTE %00100111
!BYTE %00100111
!BYTE %00100111
!BYTE %10100111
!BYTE %01010111
!BYTE %11111111

BLOCK_BUFFER_TAB_LO
 !BYTE <BLOCK_BUFFER_00,<BLOCK_BUFFER_00,<BLOCK_BUFFER_01,<BLOCK_BUFFER_01,<BLOCK_BUFFER_02,<BLOCK_BUFFER_02,<BLOCK_BUFFER_03,<BLOCK_BUFFER_03,<BLOCK_BUFFER_04,<BLOCK_BUFFER_04,<BLOCK_BUFFER_05,<BLOCK_BUFFER_05,<BLOCK_BUFFER_06,<BLOCK_BUFFER_06,<BLOCK_BUFFER_07,<BLOCK_BUFFER_07
BLOCK_BUFFER_TAB_HI
 !BYTE >BLOCK_BUFFER_00,>BLOCK_BUFFER_00,>BLOCK_BUFFER_01,>BLOCK_BUFFER_01,>BLOCK_BUFFER_02,>BLOCK_BUFFER_02,>BLOCK_BUFFER_03,>BLOCK_BUFFER_03,>BLOCK_BUFFER_04,>BLOCK_BUFFER_04,>BLOCK_BUFFER_05,>BLOCK_BUFFER_05,>BLOCK_BUFFER_06,>BLOCK_BUFFER_06,>BLOCK_BUFFER_07,>BLOCK_BUFFER_07

;!align 255,0
BLOCK_BUFFER_00 = 63*1024             ; block double shifted 0 times
BLOCK_BUFFER_01 = BLOCK_BUFFER_00 +64 ; block double shifted 7 times
BLOCK_BUFFER_02 = BLOCK_BUFFER_01 +64 ; block double shifted 7 times
BLOCK_BUFFER_03 = BLOCK_BUFFER_02 +64 ; block double shifted 7 times
BLOCK_BUFFER_04 = BLOCK_BUFFER_03 +64 ; block double shifted 7 times
BLOCK_BUFFER_05 = BLOCK_BUFFER_04 +64 ; block double shifted 7 times
BLOCK_BUFFER_06 = BLOCK_BUFFER_05 +64 ; block double shifted 7 times
BLOCK_BUFFER_07 = BLOCK_BUFFER_06 +64 ; block double shifted 7 times

; routines needed
; copy from mem (x/y) to char (a)
; copy from char (a) to mem (x/y)
; copy from char (x) to char (y)
; zp needed
; src = 2 bytes
; dst = 2 bytes

;4 character block = 32 bytes
;char 0 char 2
;char 1 char 3

;rotated 16 times = 32 bytes x 16 times = 512 bytes
;rot0
;char0 char2 >>0
;char1 char3 >>0
;...
;rot15
;char0 char2 >>15
;char1 char3 >>15

;copy char 0 and char 2 under char 1 and char 3 = 32 x 24 times = 768 bytes
;rot0
;char0 char2 >>0
;char1 char3 >>0
;char0 char2 copy of above
;...
;rot15
;char0 char2 >>15
;char1 char3 >>15
;char0 char2 copy of above

;build_screen
; 24
; 35

; 02
; 13

; tx = x and 1
; ty = y and 1 *2
; tx + ty +2

;010101010101010
;1 
;0 02
;1 13
;0
;1
;0
;1
;0
;1

; for y=31 to 0
; for x=25 to 0

; char = (x and 1)
; char = char + ((y and 1) >>1)
; char = char +2

