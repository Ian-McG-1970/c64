*= 2049
!byte $0c,$08,$0a,$00,$9e   ; Line 10 SYS
!tx "2070"            ; Address for sys start in text

SPRITES =2
REGA = SPRITES +1
REGX = REGA +1
REGY = REGX +1

BDR = $D020

SPRENBL = 53248+21
SPRXPX = 53248+29 
SPRXPY = 53248+23

S0X = 53248+0
S0Y = 53248+1
S0C = $D027
S0P = 2040

S1X = 53248+2
S1Y = 53248+3
S1C = $D028
S1P = 2041

S2X = 53248+4
S2Y = 53248+5
S2C = $D029
S2P = 2042

S3X = 53248+6
S3Y = 53248+7
S3C = $D02A
S3P = 2043

S4X = 53248+8
S4Y = 53248+9
S4C = $D02B
S4P = 2044

S5X = 53248+10
S5Y = 53248+11
S5C = $D02C
S5P = 2045

S6X = 53248+12
S6Y = 53248+13
S6C = $D02D
S6P = 2046

S7X = 53248+14
S7Y = 53248+15
S7C = $D02E
S7P = 2047

SPRXMSB = 53248+16

!ZONE CBA 
!MACRO CBA SOURCE, DEST {
    LDA SOURCE
    STA DEST
}

!ZONE CWA
!MACRO CWA SOURCE, DEST {
    LDA #<SOURCE
    STA DEST
    LDA #>SOURCE
    STA DEST +1
}

*= 2070

  SEI        ; disable maskable IRQs

  LDX   #255   ; reset stack
  TXS
 
  LDA   #$7F
  STA   $DC0D  ; disable timer interrupts which can be generated by the two CIA chips
  STA   $DD0D  ; the kernal uses such an interrupt to flash the cursor and scan the keyboard, so we better stop it.

  LDA   $DC0D  ; by reading this two registers we negate any pending CIA irqs.
  LDA   $DD0D  ; if we don't do this, a pending CIA irq might occur after we finish setting up our irq. we don't want that to happen.

  LDA   #$01   ; this is how to tell the VICII to generate a raster interrupt
  STA   $D01A

  LDA   #$1B   ; as there are more than 256 rasterlines, the topmost bit of $d011 serves as
  STA   $D011  ; the 9th bit for the rasterline we want our irq to be triggered. here we simply set up a character screen, leaving the topmost bit 0.

  LDA   #$35   ; we turn off the BASIC and KERNAL rom here
  STA   $01    ; the cpu now sees RAM everywhere except at $d000-$e000, where still the registers of SID/VICII/etc are visible

; ADR MP_IRQ, $FFFE

  LDA   #<VBL_IRQ  ; this is how we set up
  STA   $FFFE     ; the address of our interrupt code
  LDA   #>VBL_IRQ
  STA   $FFFF
  
  LDA   #255   ; this is how to tell at which rasterline we want the irq to be triggered
  STA   $D012
  
  LDA   #<NMI_NOP ; lsb
  STA   $FFFA ; Create a nop, irq handler for NMI that gets called whenever RESTORE is pressed or similar.
  LDA   #>NMI_NOP ; msb
  STA   $FFFB ; We're putting our irq handler directly in the vector that usually points to the kernal's NMI handler since we have kernal banked out.

  LDA   #$00  ; Force an NMI by setting up a timer. This will cause an NMI, that won't be acked. Any subsequent NMI's from RESTORE will be essentially disabled.
  STA   $DD0E       ; Stop timer A
  STA   $DD04       ; Set timer A to 0, NMI will occure immediately after start
  STA   $DD0E

  LDA   #$81
  STA   $DD0D       ; Set timer A as source for NMI

  LDA   #$01
  STA   $DD0E       ; Start timer A -> NMI
 
  LDA #255
  STA SPRENBL
  LDA #0
  STA SPRXPX
  STA SPRXPY
  LDA #255
  STA SPRENBL

  CLI ; enable maskable interrupts again

MLOOP:  JMP   MLOOP ; we better don't RTS, the ROMS are now switched off, there's no way back to the system

!ZONE GNOME_SORT_INIT
!MACRO GNOME_SORT_INIT POS {
            LDY SPRITE_SORTED+POS    ; get indexes
            LDX SPRITE_SORTED+POS+1
            LDA SPRITE_VPOS,X       ; compare verts
            CMP SPRITE_VPOS,Y
            BCC .NEXT               ; in order
            STX SPRITE_SORTED+POS+1  ; swap indexes
            STY SPRITE_SORTED+POS
.NEXT
}

!ZONE GNOME_SORT_ELEMENT
!MACRO GNOME_SORT_ELEMENT POS, PREV {
            LDY SPRITE_SORTED+POS    ; get indexes
            LDX SPRITE_SORTED+POS+1
            LDA SPRITE_VPOS,X       ; compare verts
            CMP SPRITE_VPOS,Y
            BCC .NEXT               ; in order
            STX SPRITE_SORTED+POS+1  ; swap indexes
            STY SPRITE_SORTED+POS
            BCS PREV                ; go back
.NEXT
}

; copy default verts to verts
;  mva orig_vert_pos, multiplex_vert_pos
;
; sort verts into order storing order in sprite-sorted-index
;  gnome_sort

; draw sprites
;  
; copy verts to raster-vert-minus2
;
; subtract 2 from raster-vert-minus2

; copy rasters to raster-vert-plus3

; add 3 to raster-vert-plus3

; setup sprite-irq with last raster-vert-minus2

; maa sprite-irq, fffe


!ZONE SPRITE 
!MACRO SPRITE VPOS, HPOS, COLOUR, POINTER, SPRITE_VPOS, SPRITE_HPOS, SPRITE_COLOUR, SPRITE_POINTER {
  LDA VPOS
  STA SPRITE_VPOS
  LDA HPOS
  STA SPRITE_HPOS
  LDA COLOUR
  STA SPRITE_COLOUR
  LDA POINTER
  STA SPRITE_POINTER
}

!ZONE PLUS_MINUS 
!MACRO PLUS_MINUS SRC, DST_P21, DST_P3, DST_M2
  CLC
  LDA SRC
  ADC #21
  STA DST_P21
  ADC #3
  STA DST_P3
  SEC
  SBC #1 ;3;5
  STA DST_M2
}

SPRITE_VPOS:          !BYTE 60,70,80,90,100,110,120,130
SPR_YPOS:             !BYTE 50,70,90,110,135,150,170,190
SPR_COL:              !BYTE 1,2,3,4,5,9,7,8
SPR_PTR:              !BYTE 128,129,130,131,132,133,134,135

SPRITE_VPOS_PLUS21:   !BYTE 0,0,0,0,0,0,0,0
SPRITE_RASTER_PLUS3:  !BYTE 0,0,0,0,0,0,0,0 ;60+21+3,70+21+3,80+21+3,90+21+3,100+21+3,110+21+3,125+21+3,130+21+3
SPRITE_RASTER_MINUS2: !BYTE 0,0,0,0,0,0,0,0 ;,60+21-2,70+21-2,80+21-2,90+21-2,100+21-2,110+21-2,125+21-2,130+21-2

SPRITE_SORTED:        !BYTE 7,6,5,4,3,2,1,0

!ZONE VBL_IRQ
VBL_IRQ:
 INC BDR
  STA REGA
  STX REGX
  STY REGY

  LDA #7
  STA SPRITES

GS0 +GNOME_SORT_INIT 0
GS1 +GNOME_SORT_ELEMENT 1, GS0
GS2 +GNOME_SORT_ELEMENT 2, GS1
GS3 +GNOME_SORT_ELEMENT 3, GS2
GS4 +GNOME_SORT_ELEMENT 4, GS3
GS5 +GNOME_SORT_ELEMENT 5, GS4
GS6 +GNOME_SORT_ELEMENT 6, GS5
;GS7 +GNOME_SORT_ELEMENT 7, GS6

  +PLUS_MINUS SPRITE_VPOS+0, SPRITE_VPOS_PLUS21+0, SPRITE_RASTER_PLUS3+0, SPRITE_RASTER_MINUS2+0
  +PLUS_MINUS SPRITE_VPOS+1, SPRITE_VPOS_PLUS21+1, SPRITE_RASTER_PLUS3+1, SPRITE_RASTER_MINUS2+1
  +PLUS_MINUS SPRITE_VPOS+2, SPRITE_VPOS_PLUS21+2, SPRITE_RASTER_PLUS3+2, SPRITE_RASTER_MINUS2+2
  +PLUS_MINUS SPRITE_VPOS+3, SPRITE_VPOS_PLUS21+3, SPRITE_RASTER_PLUS3+3, SPRITE_RASTER_MINUS2+3
  +PLUS_MINUS SPRITE_VPOS+4, SPRITE_VPOS_PLUS21+4, SPRITE_RASTER_PLUS3+4, SPRITE_RASTER_MINUS2+4
  +PLUS_MINUS SPRITE_VPOS+5, SPRITE_VPOS_PLUS21+5, SPRITE_RASTER_PLUS3+5, SPRITE_RASTER_MINUS2+5
  +PLUS_MINUS SPRITE_VPOS+6, SPRITE_VPOS_PLUS21+6, SPRITE_RASTER_PLUS3+6, SPRITE_RASTER_MINUS2+6
  +PLUS_MINUS SPRITE_VPOS+7, SPRITE_VPOS_PLUS21+7, SPRITE_RASTER_PLUS3+7, SPRITE_RASTER_MINUS2+7
  
  +SPRITE SPRITE_VPOS+7, SPR_YPOS+7, SPR_COL+7, SPR_PTR+7, S7Y, S7X, S7C, S7P
  +SPRITE SPRITE_VPOS+6, SPR_YPOS+6, SPR_COL+6, SPR_PTR+6, S6Y, S6X, S6C, S6P
  +SPRITE SPRITE_VPOS+5, SPR_YPOS+5, SPR_COL+5, SPR_PTR+5, S5Y, S5X, S5C, S5P
  +SPRITE SPRITE_VPOS+4, SPR_YPOS+4, SPR_COL+4, SPR_PTR+4, S4Y, S4X, S4C, S4P
  +SPRITE SPRITE_VPOS+3, SPR_YPOS+3, SPR_COL+3, SPR_PTR+3, S3Y, S3X, S3C, S3P
  +SPRITE SPRITE_VPOS+2, SPR_YPOS+2, SPR_COL+2, SPR_PTR+2, S2Y, S2X, S2C, S2P
  +SPRITE SPRITE_VPOS+1, SPR_YPOS+1, SPR_COL+1, SPR_PTR+1, S1Y, S1X, S1C, S1P
  +SPRITE SPRITE_VPOS+0, SPR_YPOS+0, SPR_COL+0, SPR_PTR+0, S0Y, S0X, S0C, S0P

  INC $D019
  LDA #<SPRITE_IRQ  ; this is how we set up
  STA $FFFE     ; the address of our interrupt code
  LDA #>SPRITE_IRQ
  STA $FFFF
  LDY SPRITE_SORTED+7
  LDA SPRITE_RASTER_MINUS2,Y
;  LDA #0
  STA $D012
  LDA REGA
  LDX REGX
  LDY REGY
 DEC BDR
  RTI

!ZONE SPRITE_IRQ
SPRITE_IRQ
 INC BDR
  STA REGA
  STX REGX
  STY REGY
  LDY SPRITES
  LAX SPRITE_SORTED,Y
.LOOP
    INC S0P,x
    LDY SPRITE_VPOS_PLUS21,X
    ASL
    TAX
    TYA
    STA S0X+1,X
    DEC SPRITES
    BMI SET_VBL_IRQ
    LDY SPRITES
    LAX SPRITE_SORTED,Y
    LDY SPRITE_RASTER_PLUS3-1,X ; if next one +3 greater than raster line then do next raster to top
    CPY $D012
    BCC .LOOP
  INC $D019
  LDA SPRITE_RASTER_MINUS2-1,X
  STA $D012
  LDA REGA
  LDX REGX
  LDY REGY
 DEC BDR
  RTI

SET_VBL_IRQ
  INC $D019
  LDA #<VBL_IRQ  ; this is how we set up
  STA $FFFE     ; the address of our interrupt code
  LDA #>VBL_IRQ
  STA $FFFF
  LDA #255
  STA $D012
  LDA REGA
  LDX REGX
  LDY REGY
 DEC BDR
 NMI_NOP: RTI
